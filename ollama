#!/bin/bash
# Ollama Actions CLI wrapper script
# This script can run in two modes:
# 1. Single command: Executes one command and exits.
# 2. Interactive: Enters a loop to process multiple commands.

# Not using 'set -e' to provide more specific error messages.

# --- Global Variables & Setup ---
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$SCRIPT_DIR"

# --- Argument Parsing ---
DRY_RUN=false
AUTO_CONFIRM=false
INTERACTIVE_MODE=false
PROMPT_ARGS=()
while [[ $# -gt 0 ]]; do
  case "$1" in
    -i|--interactive)
      INTERACTIVE_MODE=true
      shift
      ;;
    --dry-run)
      DRY_RUN=true
      shift
      ;;
    -y|--yes)
      AUTO_CONFIRM=true
      shift
      ;;
    *)
      PROMPT_ARGS+=("$1")
      shift
      ;;
  esac
done

# --- Load Environment & Set Variables ---
if [ -f .env ]; then
  export $(grep -E '^[A-Z_]+=' .env | xargs)
fi
APP_PORT=${APP_PORT:-8000}
PROJECT_NAME=$(basename "$PWD")
NETWORK_NAME="${PROJECT_NAME}_llm_net"
# Docker Compose converts underscores to hyphens in image names
IMAGE_NAME="${PROJECT_NAME//_/-}-ollama-cli"


# --- Core Logic Function ---
process_prompt() {
  local original_prompt_string="$*" # Store the original prompt for retries

  if [ -z "$original_prompt_string" ]; then
    return # Do nothing if prompt is empty
  fi

  # Retry loop for this specific prompt
  while true; do
    echo
    echo -e "\033[96mPrompt: \033[0m$original_prompt_string" # Display current prompt
    echo -e "\033[94mðŸ¤– Asking agent...\033[0m"

    # 1. Get the command from the container
    local GENERATED_COMMAND
    # Build docker command with optional session ID for conversation memory
    local DOCKER_CMD="docker run --rm --network \"$NETWORK_NAME\" -e \"APP_PORT=${APP_PORT}\" \"$IMAGE_NAME\" --agent-url \"http://agent:${APP_PORT}\" --get-command \"$original_prompt_string\""

    # Add session ID if in interactive mode (enables conversation context)
    if [ -n "$SESSION_ID" ]; then
      DOCKER_CMD="$DOCKER_CMD --session-id \"$SESSION_ID\""
    fi

    GENERATED_COMMAND=$(eval "$DOCKER_CMD" 2>&1)
    local DOCKER_EXIT_CODE=$?

    # Check if the output is JSON (indicating an API action was already executed)
    if echo "$GENERATED_COMMAND" | python3 -m json.tool > /dev/null 2>&1; then
        echo
        echo -e "\033[92mâœ“ Agent executed API action\033[0m"
        echo
        # Display the result (output is already JSON from the API call)
        echo "$GENERATED_COMMAND" | python3 -m json.tool
        return
    fi

    # Check for errors from the container
    if [ $DOCKER_EXIT_CODE -ne 0 ]; then
        echo
        echo -e "\033[91mâœ— The CLI tool failed inside the container (Exit Code: $DOCKER_EXIT_CODE).\033[0m"
        echo -e "\033[93mThis often means it couldn't connect to the 'agent' service.\033[0m"
        echo -e "  1. Ensure your services are running with: \033[1mdocker compose up -d\033[0m"
        echo -e "  2. Check the agent's logs for errors with: \033[1mdocker compose logs agent\033[0m"
        return # Exit process_prompt, no retry on agent failure
    fi

    if [ -z "$GENERATED_COMMAND" ]; then
        echo
        echo -e "\033[91mâœ— Failed to get a command from the agent.\033[0m"
        echo -e "\033[93mThe agent responded, but did not suggest a command to run.\033[0m"
        echo -e "  - You can check the agent's logs for more details: \033[1mdocker compose logs agent\033[0m"
        return # Exit process_prompt, no retry on empty command
    fi

    echo -e "\033[92mðŸ“‹ Generated command:\033[0m"
    echo -e "\033[1m   $GENERATED_COMMAND\033[0m"
    echo

    # 2. Handle dry run (for non-interactive mode)
    if [ "$DRY_RUN" = true ] && [ "$INTERACTIVE_MODE" = false ]; then
      echo -e "\033[96m[DRY RUN] Command not executed.\033[0m"
      return # Exit process_prompt
    fi

    # 3. Handle confirmation with 'Y/n/r'
    # Skip confirmation if AUTO_CONFIRM is true
    if [ "$AUTO_CONFIRM" = true ]; then
      echo -e "\033[92mðŸš€ Executing on host...\033[0m"
      echo
      eval "$GENERATED_COMMAND"
      return # Exit process_prompt
    fi

    local REPLY_CONFIRMATION
    printf "\033[94mExecute this command on your host? [Y/n/r]: \033[0m"
    read -r REPLY_CONFIRMATION
    echo

    case "$REPLY_CONFIRMATION" in
      [yY]|"") # Yes or Enter (default)
        echo -e "\033[92mðŸš€ Executing on host...\033[0m"
        echo
        eval "$GENERATED_COMMAND"
        break # Exit the retry loop
        ;;
      [nN]) # No
        echo -e "\033[93mCancelled.\033[0m"
        break # Exit the retry loop
        ;;
      [rR]) # Retry
        echo -e "\033[93mRetrying agent with the same prompt...\033[0m"
        # Loop continues, re-asking the agent with original_prompt_string
        ;;
      *) # Invalid input, default to No for safety
        echo -e "\033[93mInvalid input, cancelled.\033[0m"
        break # Exit the retry loop
        ;;
    esac
  done # End of retry loop for this prompt
  echo # Add a newline after the process_prompt finishes
}

# --- Main Workflow ---

# Run pre-flight checks once
if ! docker network inspect "$NETWORK_NAME" >/dev/null 2>&1; then
    echo -e "\033[91mError: Docker network '$NETWORK_NAME' not found.\033[0m"
    echo "Please run 'docker compose up -d' to create the network and services."
    exit 1
fi
if ! docker inspect --type=image "$IMAGE_NAME" >/dev/null 2>&1; then
    echo "Info: Docker image '$IMAGE_NAME' not found. Building it now..."
    docker compose build ollama-cli
    if [ $? -ne 0 ]; then
        echo -e "\033[91mError: Failed to build '$IMAGE_NAME'.\033[0m"
        exit 1
    fi

    # Verify the image was created with the correct name
    if ! docker inspect --type=image "$IMAGE_NAME" >/dev/null 2>&1; then
        echo -e "\033[91mError: Image built but not found as '$IMAGE_NAME'.\033[0m"
        echo "Available ollama images:"
        docker images | grep -E "ollama|IMAGE"
        exit 1
    fi
fi
echo -e "\033[95m\033[1mOllama Actions CLI\033[0m"


if [ "$INTERACTIVE_MODE" = true ]; then
  # --- Interactive Mode ---
  # Generate a unique session ID for this interactive session to maintain conversation context
  # Use timestamp, PID, and random number for uniqueness
  SESSION_ID="interactive-$(date +%s)-$$-$RANDOM"

  # Setup persistent command history
  HISTORY_FILE="${HOME}/.ollama_history"
  HISTORY_SIZE=1000

  # Create history file if it doesn't exist
  touch "$HISTORY_FILE"

  # Enable history for this script and set the history file for readline
  set -o history
  export HISTFILE="$HISTORY_FILE"
  export HISTSIZE="$HISTORY_SIZE"
  export HISTFILESIZE="$HISTORY_SIZE"
  export HISTCONTROL="ignoredups"  # Ignore consecutive duplicate entries
  shopt -s histappend  # Append to history file, don't overwrite

  # Load existing history from file
  history -r "$HISTORY_FILE"

  # Ensure cursor is visible
  tput cnorm 2>/dev/null || true

  echo -e "\033[92mEntering interactive mode. Type 'exit', 'quit', or Ctrl+D to leave.\033[0m"
  echo -e "\033[90m(Session ID: $SESSION_ID)\033[0m"
  echo -e "\033[90mType 'help' for available commands. Use â†‘/â†“ arrows for history.\033[0m"
  echo

  while true; do
    # Ensure cursor is visible before each prompt
    printf '\033[?25h'
    read -e -r -p $'\001\033[95m\002ollama> \001\033[0m\002' user_input
    read_status=$?

    if [ "$read_status" -ne 0 ]; then # Check for EOF (Ctrl+D)
        echo # Newline after Ctrl+D
        break # Exit the loop
    fi

    # Skip empty input
    if [ -z "$user_input" ]; then
      continue
    fi

    case "$user_input" in
      exit|quit)
        # Remove from history before exiting
        history -d -1 2>/dev/null
        break
        ;;
      history)
        # Show command history (and remove this command from history)
        history -d -1 2>/dev/null
        echo -e "\033[96m=== Command History ===\033[0m"
        history | tail -n 50
        ;;
      "clear history")
        # Clear command history
        history -c
        > "$HISTORY_FILE"
        echo -e "\033[93mHistory cleared.\033[0m"
        ;;
      clear)
        # Clear conversation context (and remove this command from history)
        history -d -1 2>/dev/null
        # Send DELETE request to clear session
        curl -s -X DELETE "http://localhost:${APP_PORT}/debug/session/${SESSION_ID}" > /dev/null 2>&1
        # Generate new session ID
        SESSION_ID="interactive-$(date +%s)-$$-$RANDOM"
        echo -e "\033[93mConversation context cleared. New session: $SESSION_ID\033[0m"
        ;;
      help)
        # Show help (and remove this command from history)
        history -d -1 2>/dev/null
        echo -e "\033[96m=== Ollama CLI Help ===\033[0m"
        echo "Commands:"
        echo "  history          - Show command history"
        echo "  clear history    - Clear command history"
        echo "  clear            - Clear conversation context (start fresh)"
        echo "  help             - Show this help"
        echo "  exit, quit       - Exit interactive mode"
        echo ""
        echo "Or type any natural language command to execute."
        ;;
      *)
        # readline from 'read -e' already added to history, just process the prompt
        process_prompt "$user_input"
        ;;
    esac
  done

  # Save final history to file
  history -w "$HISTORY_FILE"

  # Ensure cursor is visible on exit
  printf '\033[?25h'

  echo -e "\033[92mExiting interactive mode.\033[0m"

else
  # --- Single Command Mode ---
  if [ ${#PROMPT_ARGS[@]} -eq 0 ]; then
    echo "Usage: ./ollama [--interactive] [--dry-run] [--yes] <prompt>"
    echo "Example: ./ollama \"list all python files\""
    exit 1
  fi
  process_prompt "${PROMPT_ARGS[@]}"
fi
